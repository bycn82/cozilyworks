
<FileDeclaration> 
<PackageDeclaration>package 
<QualifiedName>com.cozilyworks.annotation
</QualifiedName>;
</PackageDeclaration>
<ImportDeclaration>import  
<QualifiedName>java.lang.annotation.Annotation
</QualifiedName> ;
</ImportDeclaration>
<ImportDeclaration>import  
<QualifiedName>java.lang.reflect.Method
</QualifiedName> ;
</ImportDeclaration>
<TypeDeclaration>
<ClassOrInterfaceDeclaration>
<ClassDeclaration>
<NormalClassDeclaration>
<Modifiers>
<AnnoOrKeywords>public
</AnnoOrKeywords>
</Modifiers> class TestNotation 
<ClassBody>{
<ClassBodyDeclaration>
<MemberDecl>
<MethodDeclaration>
<Modifiers>
<AnnoOrKeywords>public
</AnnoOrKeywords>
<AnnoOrKeywords>static
</AnnoOrKeywords>
</Modifiers>  
<ReturnType>void
</ReturnType> main 
<FormalParameters>( 
<FormalParameterDecls>
<NormalParameterDecl>[VariableModifiers] 
<Type>
<ClassOrInterfaceType>
<IdentifierArgs>String
</IdentifierArgs>
</ClassOrInterfaceType>[]
</Type> arg
</NormalParameterDecl>
</FormalParameterDecls> )
</FormalParameters>
<BlockOrSemi>
<Block>{
<BlockStatement>
<LocalVariableDeclarationStatement>
<LocalVariableDeclaration>[VariableModifiers] 
<Type>
<ClassOrInterfaceType>
<IdentifierArgs>A
</IdentifierArgs>
</ClassOrInterfaceType>
</Type> 
<VariableDeclarator>a= 
<VariableInitializer>
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>
<Creator>new 
<ClassOrInterfaceType>
<IdentifierArgs>A
</IdentifierArgs>
</ClassOrInterfaceType> 
<ClassCreatorRest>
<Arguments>(  )
</Arguments> 
</ClassCreatorRest>
</Creator>
</Primary>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression>
</VariableInitializer>
</VariableDeclarator>
</LocalVariableDeclaration>;
</LocalVariableDeclarationStatement>
</BlockStatement>
<BlockStatement>
<LocalVariableDeclarationStatement>
<LocalVariableDeclaration>[VariableModifiers] 
<Type>
<ClassOrInterfaceType>
<IdentifierArgs>Method
</IdentifierArgs>
</ClassOrInterfaceType>[]
</Type> 
<VariableDeclarator>ms= 
<VariableInitializer>
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>a.getClass
<IdentifierSuffix>
<Arguments>(  )
</Arguments>
</IdentifierSuffix>
</Primary>
<Selector>.getMethods 
<Arguments>(  )
</Arguments>
</Selector>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression>
</VariableInitializer>
</VariableDeclarator>
</LocalVariableDeclaration>;
</LocalVariableDeclarationStatement>
</BlockStatement>
<BlockStatement>
<Statement>
<Forstatement>for( [VariableModifiers] 
<Type>
<ClassOrInterfaceType>
<IdentifierArgs>Method
</IdentifierArgs>
</ClassOrInterfaceType>
</Type> m: 
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>ms
</Primary>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression>) 
<Statement>
<Block>{
<BlockStatement>
<LocalVariableDeclarationStatement>
<LocalVariableDeclaration>[VariableModifiers] 
<Type>
<ClassOrInterfaceType>
<IdentifierArgs>Annotation
</IdentifierArgs>
</ClassOrInterfaceType>[]
</Type> 
<VariableDeclarator>as= 
<VariableInitializer>
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>m.getAnnotations
<IdentifierSuffix>
<Arguments>(  )
</Arguments>
</IdentifierSuffix>
</Primary>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression>
</VariableInitializer>
</VariableDeclarator>
</LocalVariableDeclaration>;
</LocalVariableDeclarationStatement>
</BlockStatement>
<BlockStatement>
<Statement>
<Forstatement>for( [VariableModifiers] 
<Type>
<ClassOrInterfaceType>
<IdentifierArgs>Annotation
</IdentifierArgs>
</ClassOrInterfaceType>
</Type> aa: 
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>as
</Primary>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression>) 
<Statement>
<Block>{
<BlockStatement>
<Statement>if 
<ParExpression>( 
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>aa
</Primary>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>instanceof 
<Type>
<ClassOrInterfaceType>
<IdentifierArgs>Cozily
</IdentifierArgs>
</ClassOrInterfaceType>
</Type>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression> )
</ParExpression> 
<Statement>
<Block>{
<BlockStatement>
<Statement>
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>System.out.println
<IdentifierSuffix>
<Arguments>( 
<ExpressionList>
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>
<ParExpression>( 
<Expression>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<CastExpression>( 
<Type>
<ClassOrInterfaceType>
<IdentifierArgs>Cozily
</IdentifierArgs>
</ClassOrInterfaceType>
</Type> ) 
<UnaryExpressionNotPlusMinus>
<Primary>aa
</Primary>
</UnaryExpressionNotPlusMinus>
</CastExpression>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression> )
</ParExpression>
</Primary>
<Selector>.name 
<Arguments>(  )
</Arguments>
</Selector>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression>
</ExpressionList> )
</Arguments>
</IdentifierSuffix>
</Primary>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>  
</Expression>;
</Statement>
</BlockStatement>}
</Block>
</Statement>
</Statement>
</BlockStatement>}
</Block>
</Statement>
</Forstatement>
</Statement>
</BlockStatement>}
</Block>
</Statement>
</Forstatement>
</Statement>
</BlockStatement>}
</Block>
</BlockOrSemi>
</MethodDeclaration>
</MemberDecl>
</ClassBodyDeclaration>}
</ClassBody>
</NormalClassDeclaration>
</ClassDeclaration>
</ClassOrInterfaceDeclaration>
</TypeDeclaration>
<TypeDeclaration>
<ClassOrInterfaceDeclaration>
<ClassDeclaration>
<NormalClassDeclaration>[Modifiers] class A 
<ClassBody>{
<ClassBodyDeclaration>
<MemberDecl>
<MethodDeclaration>
<Modifiers>
<AnnoOrKeywords>
<Annotation>@ 
<QualifiedName>Cozily
</QualifiedName>( 
<ElementValueOrPairs>
<ElementValuePairs>
<ElementValuePair>name = 
<ElementValue>
<ConditionalExpression>
<ConditionalOrExpression>
<ConditionalAndExpression>
<InclusiveOrExpression>
<ExclusiveOrExpression>
<AndExpression>
<EqualityExpression>
<InstanceOfExpression>
<RelationalExpression>
<ShiftExpression>
<AdditiveExpression>
<MultiplicativeExpression>
<UnaryExpression>
<UnaryExpressionNotPlusMinus>
<Primary>
<Literal>"sdfsdf"
</Literal>
</Primary>
</UnaryExpressionNotPlusMinus>
</UnaryExpression>
</MultiplicativeExpression>
</AdditiveExpression>
</ShiftExpression>
</RelationalExpression>
</InstanceOfExpression>
</EqualityExpression>
</AndExpression>
</ExclusiveOrExpression>
</InclusiveOrExpression>
</ConditionalAndExpression>
</ConditionalOrExpression>
</ConditionalExpression>
</ElementValue>
</ElementValuePair>
</ElementValuePairs>
</ElementValueOrPairs> )
</Annotation>
</AnnoOrKeywords>
<AnnoOrKeywords>public
</AnnoOrKeywords>
</Modifiers>  
<ReturnType>void
</ReturnType> B 
<FormalParameters>(  )
</FormalParameters>
<BlockOrSemi>
<Block>{}
</Block>
</BlockOrSemi>
</MethodDeclaration>
</MemberDecl>
</ClassBodyDeclaration>}
</ClassBody>
</NormalClassDeclaration>
</ClassDeclaration>
</ClassOrInterfaceDeclaration>
</TypeDeclaration>
</FileDeclaration>