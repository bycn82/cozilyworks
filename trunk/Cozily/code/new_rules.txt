fileDeclaration 
	:	(annotations? packageDeclaration)? importDeclaration* typeDeclaration* 
->^(FILEDECLARATION0 	(annotations? packageDeclaration)? importDeclaration* typeDeclaration*)
	;
packageDeclaration 
    :   'package' qualifiedName ';'
->^(PACKAGEDECLARATION0     qualifiedName)
    ;
importDeclaration  
    :   'import' STATIC? qualifiedName DOTSTAR? ';'
->^(IMPORTDECLARATION0     STATIC? qualifiedName DOTSTAR?)
    ;
typeDeclaration 
    :   classOrInterfaceDeclaration
->^(TYPEDECLARATION0    classOrInterfaceDeclaration)
    ;
classOrInterfaceDeclaration 
    :   classDeclaration
->^(CLASSORINTERFACEDECLARATION0    classDeclaration)
    |   interfaceDeclaration
->^(CLASSORINTERFACEDECLARATION1    interfaceDeclaration)
    ;
modifiers  
    : 	modifier*
->^(MODIFIERS0  	modifier*)
    ;
modifier
    :	 annotation
->^(MODIFIER0 	 annotation)
    |   PUBLIC
->^(MODIFIER1    PUBLIC)
    |   PROTECTED
->^(MODIFIER2    PROTECTED)
    |   PRIVATE
->^(MODIFIER3    PRIVATE)
    |   STATIC
->^(MODIFIER4    STATIC)
    |   ABSTRACT
->^(MODIFIER5    ABSTRACT)
    |   FINAL
->^(MODIFIER6    FINAL)
    |   NATIVE
->^(MODIFIER7    NATIVE)
    |   SYNCHRONIZED
->^(MODIFIER8    SYNCHRONIZED)
    |   TRANSIENT
->^(MODIFIER9    TRANSIENT)
    |   VOLATILE
->^(MODIFIER10    VOLATILE)
    |   STRICTFP
->^(MODIFIER11    STRICTFP)
    ;
variableModifiers 
    :   variableModifier*
->^(VARIABLEMODIFIERS0    variableModifier*)
    ;
variableModifier
	:	annotation 
->^(VARIABLEMODIFIER0 	annotation)
	|	FINAL
->^(VARIABLEMODIFIER1 	FINAL)
	;
classDeclaration 
    :   normalClassDeclaration
->^(CLASSDECLARATION0    normalClassDeclaration)
    |   enumDeclaration
->^(CLASSDECLARATION1    enumDeclaration)
    ;
normalClassDeclaration 
    :   modifiers  'class' IDENTIFIER typeParameters? ('extends' type)? ('implements' typeList)? classBody
->^(NORMALCLASSDECLARATION0    modifiers   IDENTIFIER typeParameters? ( type)? ( typeList)? classBody)
    ;
typeParameters 
    :   '<' typeParameter (',' typeParameter)* '>'
->^(TYPEPARAMETERS0     typeParameter ( typeParameter)*)
    ;
typeParameter 
    :   IDENTIFIER ('extends' typeBound)?
->^(TYPEPARAMETER0    IDENTIFIER ( typeBound)?)
    ;
typeBound 
    :   type ('&' type)*
->^(TYPEBOUND0    type ( type)*)
    ;
enumDeclaration 
    :   modifiers 'enum' IDENTIFIER ('implements' typeList)? enumBody
->^(ENUMDECLARATION0    modifiers  IDENTIFIER ( typeList)? enumBody)
    ;
enumBody 
    :   '{' enumConstants? COMMA? (enumBodyDeclarations)? '}'
->^(ENUMBODY0     enumConstants? COMMA? (enumBodyDeclarations)?)
    ;
enumConstants 
    :   enumConstant (',' enumConstant)*
->^(ENUMCONSTANTS0    enumConstant ( enumConstant)*)
    ;
enumConstant 
    :   annotations? IDENTIFIER arguments? classBody?
->^(ENUMCONSTANT0    annotations? IDENTIFIER arguments? classBody?)
    ;
enumBodyDeclarations 
    :   ';' classBodyDeclaration*
->^(ENUMBODYDECLARATIONS0     classBodyDeclaration*)
    ;
interfaceDeclaration 
    :   normalInterfaceDeclaration
->^(INTERFACEDECLARATION0    normalInterfaceDeclaration)
    |   annotationTypeDeclaration
->^(INTERFACEDECLARATION1    annotationTypeDeclaration)
    ;
normalInterfaceDeclaration 
    :   modifiers 'interface' IDENTIFIER typeParameters?  ('extends' typeList)? interfaceBody
->^(NORMALINTERFACEDECLARATION0    modifiers  IDENTIFIER typeParameters?  ( typeList)? interfaceBody)
    ;
typeList 
    :   type (',' type)*
->^(TYPELIST0    type ( type)*)
    ;
classBody 
    :   '{' classBodyDeclaration* '}'
->^(CLASSBODY0     classBodyDeclaration*)
    ;
interfaceBody 
    :   '{' interfaceBodyDeclaration* '}'
->^(INTERFACEBODY0     interfaceBodyDeclaration*)
    ;
classBodyDeclaration 
    :   ';'
->^(CLASSBODYDECLARATION0 )
    |   STATIC? block
->^(CLASSBODYDECLARATION1    STATIC? block)
    |   memberDecl
->^(CLASSBODYDECLARATION2    memberDecl)
    ;
memberDecl 
    :    fieldDeclaration
->^(MEMBERDECL0     fieldDeclaration)
    |    methodDeclaration
->^(MEMBERDECL1     methodDeclaration)
    |    classDeclaration
->^(MEMBERDECL2     classDeclaration)
    |    interfaceDeclaration
->^(MEMBERDECL3     interfaceDeclaration)
    ;
methodDeclaration 
    :   modifiers typeParameters? IDENTIFIER formalParameters ('throws' qualifiedNameList)? '{' explicitConstructorInvocation? blockStatement* '}'
->^(METHODDECLARATION0    modifiers typeParameters? IDENTIFIER formalParameters ( qualifiedNameList)?  explicitConstructorInvocation? blockStatement*)
    |   modifiers typeParameters? returnType IDENTIFIER formalParameters BRACKETS* ('throws' qualifiedNameList)? blockOrComma
->^(METHODDECLARATION1    modifiers typeParameters? returnType IDENTIFIER formalParameters BRACKETS* ( qualifiedNameList)? blockOrComma)
    ;
blockOrComma
	:	block 
->^(BLOCKORCOMMA0 	block)
	|   SEMI  
->^(BLOCKORCOMMA1    SEMI)
	;
returnType
	:	type
->^(RETURNTYPE0 	type)
	|	VOID
->^(RETURNTYPE1 	VOID)
	;
fieldDeclaration 
    :   modifiers type variableDeclarator (',' variableDeclarator)* ';'
->^(FIELDDECLARATION0    modifiers type variableDeclarator ( variableDeclarator)*)
    ;
variableDeclarator 
    :   IDENTIFIER BRACKETS* ('=' variableInitializer)?
->^(VARIABLEDECLARATOR0    IDENTIFIER BRACKETS* ( variableInitializer)?)
    ;
interfaceBodyDeclaration 
    :   interfaceFieldDeclaration
->^(INTERFACEBODYDECLARATION0    interfaceFieldDeclaration)
    |   interfaceMethodDeclaration
->^(INTERFACEBODYDECLARATION1    interfaceMethodDeclaration)
    |   interfaceDeclaration
->^(INTERFACEBODYDECLARATION2    interfaceDeclaration)
    |   classDeclaration
->^(INTERFACEBODYDECLARATION3    classDeclaration)
    |   SEMI
->^(INTERFACEBODYDECLARATION4    SEMI)
    ;
interfaceMethodDeclaration 
    :   modifiers typeParameters? returnType IDENTIFIER formalParameters BRACKETS* ('throws' qualifiedNameList)? ';'
->^(INTERFACEMETHODDECLARATION0    modifiers typeParameters? returnType IDENTIFIER formalParameters BRACKETS* ( qualifiedNameList)?)
    ;
interfaceFieldDeclaration 
    :   modifiers type variableDeclarator (',' variableDeclarator)* ';'
->^(INTERFACEFIELDDECLARATION0    modifiers type variableDeclarator ( variableDeclarator)*)
    ;
type 
    :   classOrInterfaceType BRACKETS*
->^(TYPE0    classOrInterfaceType BRACKETS*)
    |   primitiveType BRACKETS*
->^(TYPE1    primitiveType BRACKETS*)
    ;
classOrInterfaceType 
    :   IDENTIFIER typeArguments? ('.' IDENTIFIER typeArguments? )*
->^(CLASSORINTERFACETYPE0    IDENTIFIER typeArguments? ( IDENTIFIER typeArguments? )*)
    ;
primitiveType  
    :   BOOLEAN
->^(PRIMITIVETYPE0    BOOLEAN)
    |   CHAR
->^(PRIMITIVETYPE1    CHAR)
    |   BYTE
->^(PRIMITIVETYPE2    BYTE)
    |   SHORT
->^(PRIMITIVETYPE3    SHORT)
    |   INT
->^(PRIMITIVETYPE4    INT)
    |   LONG
->^(PRIMITIVETYPE5    LONG)
    |   FLOAT
->^(PRIMITIVETYPE6    FLOAT)
    |   DOUBLE
->^(PRIMITIVETYPE7    DOUBLE)
    ;
typeArguments 
    :   '<' typeArgument (',' typeArgument)* '>'
->^(TYPEARGUMENTS0     typeArgument ( typeArgument)*)
    ;
typeArgument 
    :   type
->^(TYPEARGUMENT0    type)
    |   '?' ( extendsOrSuper type )?
->^(TYPEARGUMENT1     ( extendsOrSuper type )?)
    ;
extendsOrSuper
	:	EXTENDS
->^(EXTENDSORSUPER0 	EXTENDS)
	|	SUPER
->^(EXTENDSORSUPER1 	SUPER)
	;
qualifiedNameList 
    :    (',' qualifiedName)*
->^(QUALIFIEDNAMELIST0     ( qualifiedName)*)
    ;
formalParameters 
    :   '('formalParameterDecls? ')'
->^(FORMALPARAMETERS0    formalParameterDecls?)
    ;
formalParameterDecls 
    :   ellipsisParameterDecl
->^(FORMALPARAMETERDECLS0    ellipsisParameterDecl)
    |   normalParameterDecl (',' normalParameterDecl)*
->^(FORMALPARAMETERDECLS1    normalParameterDecl ( normalParameterDecl)*)
    |   (normalParameterDecl ',')+ ellipsisParameterDecl
->^(FORMALPARAMETERDECLS2    (normalParameterDecl )+ ellipsisParameterDecl)
    ;
normalParameterDecl 
    :   variableModifiers type IDENTIFIER BRACKETS*
->^(NORMALPARAMETERDECL0    variableModifiers type IDENTIFIER BRACKETS*)
    ;
ellipsisParameterDecl 
    :   variableModifiers type  '...' IDENTIFIER
->^(ELLIPSISPARAMETERDECL0    variableModifiers type   IDENTIFIER)
    ;
explicitConstructorInvocation 
    :   nonWildcardTypeArguments? thisOrSuper arguments ';' 
->^(EXPLICITCONSTRUCTORINVOCATION0    nonWildcardTypeArguments? thisOrSuper arguments)
    |   primary '.' nonWildcardTypeArguments? 'super' arguments ';'
->^(EXPLICITCONSTRUCTORINVOCATION1    primary  nonWildcardTypeArguments?  arguments)
    ;
thisOrSuper
	:	THIS
->^(THISORSUPER0 	THIS)
	|	SUPER
->^(THISORSUPER1 	SUPER)
	;
qualifiedName 
    :   IDENTIFIER ('.' IDENTIFIER)*
->^(QUALIFIEDNAME0    IDENTIFIER ( IDENTIFIER)*)
    ;
annotations 
    :   annotation+
->^(ANNOTATIONS0    annotation+)
    ;
annotation 
    :   '@' qualifiedName (   '(' elementOfAnno?  ')' )?
->^(ANNOTATION0     qualifiedName (    elementOfAnno?   )?)
    ;
elementOfAnno
	:	elementValuePairs 
->^(ELEMENTOFANNO0 	elementValuePairs)
	|	elementValue
->^(ELEMENTOFANNO1 	elementValue)
	;
elementValuePairs 
    :   elementValuePair (',' elementValuePair)*
->^(ELEMENTVALUEPAIRS0    elementValuePair ( elementValuePair)*)
    ;
elementValuePair 
    :   IDENTIFIER '=' elementValue
->^(ELEMENTVALUEPAIR0    IDENTIFIER  elementValue)
    ;
elementValue 
    :   conditionalExpression
->^(ELEMENTVALUE0    conditionalExpression)
    |   annotation
->^(ELEMENTVALUE1    annotation)
    |   elementValueArrayInitializer
->^(ELEMENTVALUE2    elementValueArrayInitializer)
    ;
elementValueArrayInitializer 
    :   '{'(elementValue  (',' elementValue)*  )? COMMA? '}'
->^(ELEMENTVALUEARRAYINITIALIZER0    (elementValue  ( elementValue)*  )? COMMA?)
    ;
annotationTypeDeclaration 
    :   modifiers '@' 'interface' IDENTIFIER annotationTypeBody
->^(ANNOTATIONTYPEDECLARATION0    modifiers   IDENTIFIER annotationTypeBody)
    ;
annotationTypeBody 
    :   '{' annotationTypeElementDeclaration* '}'
->^(ANNOTATIONTYPEBODY0     annotationTypeElementDeclaration*)
    ;
annotationTypeElementDeclaration 
    :   annotationMethodDeclaration
->^(ANNOTATIONTYPEELEMENTDECLARATION0    annotationMethodDeclaration)
    |   interfaceFieldDeclaration
->^(ANNOTATIONTYPEELEMENTDECLARATION1    interfaceFieldDeclaration)
    |   normalClassDeclaration
->^(ANNOTATIONTYPEELEMENTDECLARATION2    normalClassDeclaration)
    |   normalInterfaceDeclaration
->^(ANNOTATIONTYPEELEMENTDECLARATION3    normalInterfaceDeclaration)
    |   enumDeclaration
->^(ANNOTATIONTYPEELEMENTDECLARATION4    enumDeclaration)
    |   annotationTypeDeclaration
->^(ANNOTATIONTYPEELEMENTDECLARATION5    annotationTypeDeclaration)
    |   ';'
->^(ANNOTATIONTYPEELEMENTDECLARATION6 )
    ;
annotationMethodDeclaration 
    :   modifiers type IDENTIFIER '(' ')' ('default' elementValue)? ';'
->^(ANNOTATIONMETHODDECLARATION0    modifiers type IDENTIFIER   ( elementValue)?)
    ;
block 
    :   '{' blockStatement* '}'
->^(BLOCK0     blockStatement*)
    ;
blockStatement 
    :   localVariableDeclarationStatement
->^(BLOCKSTATEMENT0    localVariableDeclarationStatement)
    |   classOrInterfaceDeclaration
->^(BLOCKSTATEMENT1    classOrInterfaceDeclaration)
    |   statement
->^(BLOCKSTATEMENT2    statement)
    ;
localVariableDeclarationStatement 
    :   localVariableDeclaration ';'
->^(LOCALVARIABLEDECLARATIONSTATEMENT0    localVariableDeclaration)
    ;
localVariableDeclaration 
    :   variableModifiers type variableDeclarator (',' variableDeclarator)*
->^(LOCALVARIABLEDECLARATION0    variableModifiers type variableDeclarator ( variableDeclarator)*)
    ;
statement 
    :   block
->^(STATEMENT0    block)
    |   'assert'  expression (':' expression)? ';'    
->^(STATEMENT1      expression ( expression)?)
    |   'if' parExpression statement ('else' statement)?      
->^(STATEMENT2     parExpression statement ( statement)?)
    |   forstatement
->^(STATEMENT3    forstatement)
    |   'while' parExpression statement
->^(STATEMENT4     parExpression statement)
    |   'do' statement 'while' parExpression ';'
->^(STATEMENT5     statement  parExpression)
    |   trystatement
->^(STATEMENT6    trystatement)
    |   'switch' parExpression '{' switchBlockStatementGroups '}'
->^(STATEMENT7     parExpression  switchBlockStatementGroups)
    |   'synchronized' parExpression block
->^(STATEMENT8     parExpression block)
    |   'return' expression? ';'
->^(STATEMENT9     expression?)
    |   'throw' expression ';'
->^(STATEMENT10     expression)
    |   'break' IDENTIFIER? ';'
->^(STATEMENT11     IDENTIFIER?)
    |   'continue'IDENTIFIER? ';'
->^(STATEMENT12    IDENTIFIER?)
    |   expression  ';'     
->^(STATEMENT13    expression)
    |   IDENTIFIER ':' statement
->^(STATEMENT14    IDENTIFIER  statement)
    |   SEMI
->^(STATEMENT15    SEMI)
    ;
switchBlockStatementGroups 
    :   switchBlockStatementGroup*
->^(SWITCHBLOCKSTATEMENTGROUPS0    switchBlockStatementGroup*)
    ;
switchBlockStatementGroup 
    :   switchLabel blockStatement*
->^(SWITCHBLOCKSTATEMENTGROUP0    switchLabel blockStatement*)
    ;
switchLabel 
    :   CASE expression ':'
->^(SWITCHLABEL0    CASE expression)
    |   DEFAULT ':'
->^(SWITCHLABEL1    DEFAULT)
    ;
trystatement 
    :   'try' block   catches 'finally' block
->^(TRYSTATEMENT0     block   catches  block)
	| 'try' block  catches
->^(TRYSTATEMENT1   block  catches)
    | 'try' block  'finally' block    
->^(TRYSTATEMENT2   block   block)
    ;
catches 
    :   catchClause+
->^(CATCHES0    catchClause+)
    ;
catchClause 
    :   'catch' '(' formalParameter ')' block 
->^(CATCHCLAUSE0      formalParameter  block)
    ;
formalParameter 
    :   variableModifiers type IDENTIFIER BRACKETS*
->^(FORMALPARAMETER0    variableModifiers type IDENTIFIER BRACKETS*)
    ;
forstatement 
    :   'for' '(' variableModifiers type IDENTIFIER ':' expression ')' statement
->^(FORSTATEMENT0      variableModifiers type IDENTIFIER  expression  statement)
    |   'for' '(' forInit? ';' expression? ';' expressionList? ')' statement
->^(FORSTATEMENT1      forInit?  expression?  expressionList?  statement)
    ;
forInit 
    :   localVariableDeclaration
->^(FORINIT0    localVariableDeclaration)
    |   expressionList
->^(FORINIT1    expressionList)
    ;
parExpression 
    :   '(' expression ')'
->^(PAREXPRESSION0     expression)
    ;
expressionList 
    :   expression (',' expression)*
->^(EXPRESSIONLIST0    expression ( expression)*)
    ;
expression 
    :   conditionalExpression (assignmentOperator expression)?
->^(EXPRESSION0    conditionalExpression (assignmentOperator expression)?)
    ;
assignmentOperator 
    :   EQ
->^(ASSIGNMENTOPERATOR0    EQ)
    |   PLUSEQ
->^(ASSIGNMENTOPERATOR1    PLUSEQ)
    |   SUBEQ
->^(ASSIGNMENTOPERATOR2    SUBEQ)
    |   STAREQ
->^(ASSIGNMENTOPERATOR3    STAREQ)
    |   SLASHEQ
->^(ASSIGNMENTOPERATOR4    SLASHEQ)
    |   AMPEQ
->^(ASSIGNMENTOPERATOR5    AMPEQ)
    |   BAREQ
->^(ASSIGNMENTOPERATOR6    BAREQ)
    |   CARETEQ
->^(ASSIGNMENTOPERATOR7    CARETEQ)
    |   PERCENTEQ
->^(ASSIGNMENTOPERATOR8    PERCENTEQ)
    |   LT LT EQ
->^(ASSIGNMENTOPERATOR9    LT LT EQ)
    |   GT GT GT EQ
->^(ASSIGNMENTOPERATOR10    GT GT GT EQ)
    |   GT GT EQ
->^(ASSIGNMENTOPERATOR11    GT GT EQ)
    ;
conditionalExpression 
    :   conditionalOrExpression ('?' expression ':' conditionalExpression)?
->^(CONDITIONALEXPRESSION0    conditionalOrExpression ( expression  conditionalExpression)?)
    ;
conditionalOrExpression 
    :   conditionalAndExpression ('||' conditionalAndExpression)*
->^(CONDITIONALOREXPRESSION0    conditionalAndExpression ( conditionalAndExpression)*)
    ;
conditionalAndExpression 
    :   inclusiveOrExpression ('&&' inclusiveOrExpression)*
->^(CONDITIONALANDEXPRESSION0    inclusiveOrExpression ( inclusiveOrExpression)*)
    ;
inclusiveOrExpression 
    :   exclusiveOrExpression ('|' exclusiveOrExpression)*
->^(INCLUSIVEOREXPRESSION0    exclusiveOrExpression ( exclusiveOrExpression)*)
    ;
exclusiveOrExpression 
    :   andExpression ('^' andExpression)*
->^(EXCLUSIVEOREXPRESSION0    andExpression ( andExpression)*)
    ;
andExpression 
    :   equalityExpression ('&' equalityExpression)*
->^(ANDEXPRESSION0    equalityExpression ( equalityExpression)*)
    ;
equalityExpression 
    :   instanceOfExpression ( equalOrNotequal instanceOfExpression)*
->^(EQUALITYEXPRESSION0    instanceOfExpression ( equalOrNotequal instanceOfExpression)*)
    ;
equalOrNotequal
	:	EQEQ
->^(EQUALORNOTEQUAL0 	EQEQ)
	|	BANGEQ
->^(EQUALORNOTEQUAL1 	BANGEQ)
	;
instanceOfExpression 
    :   relationalExpression ('instanceof' type )?
->^(INSTANCEOFEXPRESSION0    relationalExpression ( type )?)
    ;
relationalExpression 
    :   shiftExpression (relationalOp shiftExpression)*
->^(RELATIONALEXPRESSION0    shiftExpression (relationalOp shiftExpression)*)
    ;
relationalOp 
    :   LT EQ
->^(RELATIONALOP0    LT EQ)
    |   GT EQ
->^(RELATIONALOP1    GT EQ)
    |   LT
->^(RELATIONALOP2    LT)
    |   GT
->^(RELATIONALOP3    GT)
    ;
shiftExpression 
    :   additiveExpression (shiftOp additiveExpression)*
->^(SHIFTEXPRESSION0    additiveExpression (shiftOp additiveExpression)*)
    ;
shiftOp 
    :    LT LT
->^(SHIFTOP0     LT LT)
    |    GT GT
->^(SHIFTOP1     GT GT)
    |    GT GT GT
->^(SHIFTOP2     GT GT GT)
    ;
additiveExpression 
    :   multiplicativeExpression ( plusOrMinus multiplicativeExpression)*
->^(ADDITIVEEXPRESSION0    multiplicativeExpression ( plusOrMinus multiplicativeExpression)*)
    ;
plusOrMinus
	:	PLUS
->^(PLUSORMINUS0 	PLUS)
	|	SUB
->^(PLUSORMINUS1 	SUB)
	;
multiplicativeExpression 
    :	unaryExpression ( timesDivide unaryExpression)*
->^(MULTIPLICATIVEEXPRESSION0 	unaryExpression ( timesDivide unaryExpression)*)
    ;
timesDivide
	:	STAR
->^(TIMESDIVIDE0 	STAR)
	|	SLASH
->^(TIMESDIVIDE1 	SLASH)
	|	PERCENT
->^(TIMESDIVIDE2 	PERCENT)
	;
unaryExpression 
    :   '+'  unaryExpression
->^(UNARYEXPRESSION0      unaryExpression)
    |   '-' unaryExpression
->^(UNARYEXPRESSION1     unaryExpression)
    |   '++' unaryExpression
->^(UNARYEXPRESSION2     unaryExpression)
    |   '--' unaryExpression
->^(UNARYEXPRESSION3     unaryExpression)
    |   unaryExpressionNotPlusMinus
->^(UNARYEXPRESSION4    unaryExpressionNotPlusMinus)
    ;
unaryExpressionNotPlusMinus 
    :   '~' unaryExpression
->^(UNARYEXPRESSIONNOTPLUSMINUS0     unaryExpression)
    |   '!' unaryExpression
->^(UNARYEXPRESSIONNOTPLUSMINUS1     unaryExpression)
    |   castExpression
->^(UNARYEXPRESSIONNOTPLUSMINUS2    castExpression)
    |   primary selector* doublePlusMinus?
->^(UNARYEXPRESSIONNOTPLUSMINUS3    primary selector* doublePlusMinus?)
    ;
doublePlusMinus
	:	PLUSPLUS
->^(DOUBLEPLUSMINUS0 	PLUSPLUS)
	|	SUBSUB
->^(DOUBLEPLUSMINUS1 	SUBSUB)
	;
castExpression 
    :   '(' primitiveType ')' unaryExpression
->^(CASTEXPRESSION0     primitiveType  unaryExpression)
    |   '(' type ')' unaryExpressionNotPlusMinus
->^(CASTEXPRESSION1     type  unaryExpressionNotPlusMinus)
    ;
primary 
    :   parExpression            
->^(PRIMARY0    parExpression)
    |   'this' ('.' IDENTIFIER)* identifierSuffix?
->^(PRIMARY1     ( IDENTIFIER)* identifierSuffix?)
    |   IDENTIFIER ('.' IDENTIFIER)* identifierSuffix?
->^(PRIMARY2    IDENTIFIER ( IDENTIFIER)* identifierSuffix?)
    |   'super' superSuffix
->^(PRIMARY3     superSuffix)
    |   literal
->^(PRIMARY4    literal)
    |   creator
->^(PRIMARY5    creator)
    |   primitiveType (BRACKETS)* '.' 'class'
->^(PRIMARY6    primitiveType (BRACKETS)*)
    |   'void' '.' 'class'
->^(PRIMARY7 )
    ;
superSuffix  
    :   arguments
->^(SUPERSUFFIX0    arguments)
    |   '.' typeArguments? IDENTIFIER arguments?
->^(SUPERSUFFIX1     typeArguments? IDENTIFIER arguments?)
    ;
identifierSuffix 
    :   BRACKETS+ '.' 'class'
->^(IDENTIFIERSUFFIX0    BRACKETS+)
    |   ('[' expression ']' )+
->^(IDENTIFIERSUFFIX1    ( expression  )+)
    |   arguments
->^(IDENTIFIERSUFFIX2    arguments)
    |   '.' 'class'
->^(IDENTIFIERSUFFIX3 )
    |   '.' nonWildcardTypeArguments IDENTIFIER arguments
->^(IDENTIFIERSUFFIX4     nonWildcardTypeArguments IDENTIFIER arguments)
    |   '.' 'this'
->^(IDENTIFIERSUFFIX5 )
    |   '.' 'super' arguments
->^(IDENTIFIERSUFFIX6      arguments)
    |   innerCreator
->^(IDENTIFIERSUFFIX7    innerCreator)
    ;
selector  
    :   '.' IDENTIFIER arguments?
->^(SELECTOR0     IDENTIFIER arguments?)
    |   '.' 'this'
->^(SELECTOR1 )
    |   '.' 'super' superSuffix
->^(SELECTOR2      superSuffix)
    |   innerCreator
->^(SELECTOR3    innerCreator)
    |   '[' expression ']'
->^(SELECTOR4     expression)
    ;
creator 
    :   'new' nonWildcardTypeArguments classOrInterfaceType classCreatorRest
->^(CREATOR0     nonWildcardTypeArguments classOrInterfaceType classCreatorRest)
    |   'new' classOrInterfaceType classCreatorRest
->^(CREATOR1     classOrInterfaceType classCreatorRest)
    |   arrayCreator
->^(CREATOR2    arrayCreator)
    ;
arrayCreator 
    :   'new' createdName BRACKETS+ arrayInitializer
->^(ARRAYCREATOR0     createdName BRACKETS+ arrayInitializer)
    |   'new' createdName '[' expression ']' (   '[' expression ']')* BRACKETS*
->^(ARRAYCREATOR1     createdName  expression  (    expression )* BRACKETS*)
    ;
variableInitializer 
    :   arrayInitializer
->^(VARIABLEINITIALIZER0    arrayInitializer)
    |   expression
->^(VARIABLEINITIALIZER1    expression)
    ;
arrayInitializer 
    :   '{' (variableInitializer (',' variableInitializer )* )? (COMMA)? '}' 
->^(ARRAYINITIALIZER0     (variableInitializer ( variableInitializer )* )? (COMMA)?)
    ;
createdName 
    :   classOrInterfaceType
->^(CREATEDNAME0    classOrInterfaceType)
    |   primitiveType
->^(CREATEDNAME1    primitiveType)
    ;
innerCreator  
    :   '.' 'new' nonWildcardTypeArguments? IDENTIFIER typeArguments?  classCreatorRest
->^(INNERCREATOR0      nonWildcardTypeArguments? IDENTIFIER typeArguments?  classCreatorRest)
    ;
classCreatorRest 
    :   arguments classBody?
->^(CLASSCREATORREST0    arguments classBody?)
    ;
nonWildcardTypeArguments 
    :   '<' typeList '>'
->^(NONWILDCARDTYPEARGUMENTS0     typeList)
    ;
arguments 
    :   '(' expressionList? ')'
->^(ARGUMENTS0     expressionList?)
    ;
literal 
    :   INTLITERAL
->^(LITERAL0    INTLITERAL)
    |   LONGLITERAL
->^(LITERAL1    LONGLITERAL)
    |   FLOATLITERAL
->^(LITERAL2    FLOATLITERAL)
    |   DOUBLELITERAL
->^(LITERAL3    DOUBLELITERAL)
    |   CHARLITERAL
->^(LITERAL4    CHARLITERAL)
    |   STRINGLITERAL
->^(LITERAL5    STRINGLITERAL)
    |   TRUE
->^(LITERAL6    TRUE)
    |   FALSE
->^(LITERAL7    FALSE)
    |   NULL
->^(LITERAL8    NULL)
    ;
